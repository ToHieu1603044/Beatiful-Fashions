import React, { useEffect, useState } from "react";
import { Table, Modal, Button, Select, Pagination, Input } from "antd";
import { confirmOrder, getOrder, getOrderReturns, getOrders, updateOrderStatus } from "../../../services/orderService";
import Swal from 'sweetalert2'
import EditOrderModal from "./EditOrderModal";
import OrderDetailModal from "../../../components/OrderDetailModal ";
import { exportPdf } from "../../../services/homeService";

const Orders: React.FC = () => {
  const [orders, setOrders] = useState([]);
  const [selectedOrder, setSelectedOrder] = useState<Order | null>(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [status, setStatus] = useState("pending");
  const [currentPage, setCurrentPage] = useState(1);
  const [lastPage, setLastPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [filterStatus, setFilterStatus] = useState<string | null>(null);
  const [editOrder, setEditOrder] = useState(null);

  useEffect(() => {
    fetchOrders(currentPage, filterStatus);
  }, [currentPage, filterStatus]);

  const handleEditOrder = async (order) => {
    try {
      const response = await getOrder(order.id);

      console.log("Chi ti·∫øt ƒë∆°n h√†ng:---", response.data.data);
      setEditOrder(response.data.data);
    } catch (error) {
      console.error("L·ªói khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng:", error);
    }
  };


  const fetchOrders = async (page = 1, trackingStatus?: string | null, userSearch?: string) => {
    try {
      setLoading(true);
      const response = await getOrders({ page, tracking_status: trackingStatus, user: userSearch });
      const res = await getOrderReturns();
      console.log("response", response);

      console.log("Danh s√°ch ƒë∆°n h√†ng:---", res.data.data);
      setOrders(response.data.data);
      setCurrentPage(response.data.page.currentPage);
      setLastPage(response.data.page.lastPage);
    } catch (error) {
      console.error("L·ªói l·∫•y danh s√°ch ƒë∆°n h√†ng:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleConfirmOrder = async () => {
    const result = await Swal.fire({
      title: "X√°c nh·∫≠n ƒë∆°n h√†ng?",
      text: "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√°c nh·∫≠n ƒë∆°n h√†ng n√†y kh√¥ng?",
      icon: "warning",
      showCancelButton: true,
      confirmButtonColor: "#3085d6",
      cancelButtonColor: "#d33",
      confirmButtonText: "X√°c nh·∫≠n",
      cancelButtonText: "H·ªßy",
    });

    if (result.isConfirmed) {
      try {
        await confirmOrder(selectedOrder.id);
        Swal.fire("Th√†nh c√¥ng!", "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n.", "success");
        fetchOrders(currentPage);
      } catch (error) {
        console.error("L·ªói x√°c nh·∫≠n ƒë∆°n h√†ng:", error);
        Swal.fire("L·ªói!", "Kh√¥ng th·ªÉ x√°c nh·∫≠n ƒë∆°n h√†ng.", "error");
      }
    }
  };
  const handleShowModal = (order: Order) => {
    setSelectedOrder(order);
    setStatus(order.shipping_status);
    setModalVisible(true);
  };

  const handleCloseModal = () => {
    setModalVisible(false);
    setSelectedOrder(null);
  };
  const handleUpdateStatusInline = async (orderId: number, newStatus: string) => {
    try {
      await updateOrderStatus(orderId, newStatus);
      Swal.fire("C·∫≠p nh·∫≠t th√†nh c√¥ng", "Tr·∫°ng th√°i ƒë∆°n h√†ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.", "success");
      fetchOrders(currentPage, filterStatus);
    } catch (error) {
      console.error("L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i:", error);
      Swal.fire("L·ªói", "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng.", "error");
    }
  };
  const handleMarkAsPaid = async (orderId: number) => {
    const result = await Swal.fire({
      title: "X√°c nh·∫≠n ƒë√£ nh·∫≠n ti·ªÅn?",
      text: "B·∫°n ch·∫Øc ch·∫Øn ƒë√£ nh·∫≠n ti·ªÅn ƒë∆°n h√†ng n√†y?",
      icon: "question",
      showCancelButton: true,
      confirmButtonText: "ƒê√£ nh·∫≠n",
      cancelButtonText: "H·ªßy",
      confirmButtonColor: "#3085d6",
      cancelButtonColor: "#d33",
    });

    if (result.isConfirmed) {
      try {
        await confirmOrder(orderId);
        Swal.fire("Th√†nh c√¥ng", "ƒê√£ ƒë√°nh d·∫•u l√† ƒë√£ nh·∫≠n ti·ªÅn.", "success");
        fetchOrders(currentPage);
      } catch (error) {
        console.error("L·ªói khi ƒë√°nh d·∫•u ƒë√£ nh·∫≠n ti·ªÅn:", error);
        Swal.fire("L·ªói!", "Kh√¥ng th·ªÉ ƒë√°nh d·∫•u ƒë∆°n h√†ng.", "error");
      }
    }
  };


  const handleUpdateStatus = async () => {
    if (!selectedOrder) return;

    try {
      console.log("Du lieu gui di", selectedOrder.id, status);

      await updateOrderStatus(selectedOrder.id, status);
      Swal.fire("Th√†nh c√¥ng!", "C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh c√¥ng.", "success");

      handleCloseModal();
      fetchOrders(currentPage, filterStatus);
    } catch (error) {
      console.log(error);
      Swal.fire("L·ªói!", "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng.", "error");
    }
  };

  const trackingStatusMap: Record<string, string> = {
    pending: "Ch·ªù x·ª≠ l√Ω",
    processing: "ƒêang x·ª≠ l√Ω",
    shipped: "ƒê√£ v·∫≠n chuy·ªÉn",
    delivered: "ƒê√£ giao h√†ng",
    cancelled: "ƒê√£ h·ªßy",
    completed: "Ho√†n th√†nh"
  };

  const handleExportPDF = async () => {
    try {
      const response = await exportPdf({
        responseType: "blob",
      });

      if (response.status === 200) {
        // T·∫°o URL t·ª´ Blob
        const url = window.URL.createObjectURL(new Blob([response.data]));
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", "all_invoices.pdf");
        document.body.appendChild(link);
        link.click();
        link.remove();

        alert("Xu·∫•t PDF th√†nh c√¥ng! üìÑ");
      }
    } catch (error) {
      console.error("L·ªói khi xu·∫•t PDF:", error);
      alert("C√≥ l·ªói x·∫£y ra khi xu·∫•t PDF!");
    }
  };

  const columns = [
    { title: "ID", dataIndex: "id", key: "id" },
    { title: "T√™n ", dataIndex: "name", key: "name" },
    {
      title: "T·ªïng ti·ªÅn ",
      dataIndex: "total_amount",
      key: "total_amount",
      render: (amount: number) =>
        amount.toLocaleString("vi-VN", { style: "currency", currency: "VND" }),
    },
    {
      title: "Tr·∫°ng th√°i giao h√†ng",
      dataIndex: "tracking_status",
      key: "tracking_status",
      render: (status: string) => trackingStatusMap[status] || "Kh√¥ng x√°c ƒë·ªãnh",
    },
    {
      title: "Ph∆∞∆°ng th·ª©c thanh to√°n ",
      dataIndex: "is_paid",
      key: "is_paid",
      render: (isPaid: boolean) =>
        isPaid ? <span style={{ color: "green" }}>‚úÖ ƒê√£ thanh to√°n</span> : <span style={{ color: "red" }}>‚ùå Ch∆∞a thanh to√°n</span>,
    },
    {
      title: "ƒê·ªãa ch·ªâ ",
      key: "address",
      render: (record: any) =>
        `${record.city}-${record.district}-${record.ward}-${record.address}`.slice(0, 30) + "...",
    },
    {
      title: "Tr·∫°ng th√°i giao h√†ng",
      dataIndex: "tracking_status",
      key: "tracking_status",
      render: (status: string, record: any) => {
        const validNextStatuses: Record<string, string[]> = {
          pending: ["processing", "cancelled"],
          processing: ["shipped", "cancelled"],
          shipped: ["delivered"],
          delivered: ["completed"],
          completed: [],
          cancelled: []
        };

        const allStatuses = [
          { value: "pending", label: "Ch·ªù x·ª≠ l√Ω" },
          { value: "processing", label: "ƒê√£ x√°c nh·∫≠n" },
          { value: "shipped", label: "ƒê√£ g·ª≠i" },
          { value: "delivered", label: "ƒêang giao" },
          { value: "cancelled", label: "ƒê√£ h·ªßy" },
          { value: "completed", label: "Giao h√†ng th√†nh c√¥ng" },
        ];

        const allowed = validNextStatuses[status] || [];

        return (
          <Select
            value={status}
            onChange={(value) => handleUpdateStatusInline(record.id, value)}
            disabled={status === 'completed' || status === 'cancelled'}
            style={{ width: 180 }}
          >
            {allStatuses.map((item) => (
              <Select.Option
                key={item.value}
                value={item.value}
                disabled={item.value === status || !allowed.includes(item.value)}
              >
                {item.label}
              </Select.Option>
            ))}
          </Select>
        );
      }
    },
    {
      title: "H√†nh ƒë·ªông",
      key: "actions",
      render: (record: any) => (
        <Button.Group>
          <Button type="primary" onClick={() => handleShowModal(record)}>View</Button>
          <Button type="primary" onClick={() => handleEditOrder(record)}>Edit</Button>

          {record.tracking_status === 'completed' && (
            <Button
              type="default"
              disabled={record.is_paid === 1}
              style={{
                marginLeft: 8,
                backgroundColor: record.is_paid === 1 ? "#ccc" : "#4CAF50",
                color: record.is_paid === 1 ? "#666" : "white",
                cursor: record.is_paid === 1 ? "not-allowed" : "pointer",
              }}
              onClick={() => handleMarkAsPaid(record.id)}
            >
              ƒê√£ nh·∫≠n ti·ªÅn
            </Button>
          )}

        </Button.Group>
      ),
    }

  ];
  return (
    <div className="container mt-4">
      <h2>Orders List</h2>
      <div className="mb-4 flex gap-3">
        <Select
          placeholder="L·ªçc theo tr·∫°ng th√°i"
          allowClear
          className="w-40"
          value={filterStatus}
          onChange={(value) => {
            setStatus(value);
            setFilterStatus(value || null);
            fetchOrders(1, value || null);
          }}
          disabled={selectedOrder?.tracking_status === 'completed'} 
        >
          <Select.Option value="pending">Ch·ªù x·ª≠ l√Ω</Select.Option>
          <Select.Option value="processing">ƒê√£ x√°c nh·∫≠n</Select.Option>
          <Select.Option value="shipped">ƒê√£ g·ª≠i</Select.Option>
          <Select.Option value="delivered">ƒêang giao</Select.Option>
          <Select.Option value="cancelled">ƒê√£ h·ªßy</Select.Option>
          <Select.Option value="completed">Giao h√†ng th√†nh c√¥ng</Select.Option>
        </Select>


        <div className="text-end mb-3">
          <Button danger onClick={handleExportPDF}>üìÑ Export PDF</Button>
        </div>

      </div>

      <Table columns={columns} dataSource={orders} loading={loading} pagination={false} rowKey="id" />
      {editOrder && (
        <EditOrderModal
          order={editOrder}
          visible={true}
          onClose={() => setEditOrder(null)}
        />
      )}
      <Pagination
        current={currentPage}
        total={lastPage * 10}
        onChange={(page) => page >= 1 && page <= lastPage && fetchOrders(page)}
        className="mt-4 text-center"
      />

      <OrderDetailModal
        order={selectedOrder}
        visible={modalVisible}
        onClose={handleCloseModal}
        status={status}
        setStatus={setStatus} // ƒê·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
        onConfirmOrder={handleUpdateStatus} // C·∫≠p nh·∫≠t tr·∫°ng th√°i khi x√°c nh·∫≠n
        confirmOrder={handleMarkAsPaid}
      />

    </div>
  );
};

export default Orders;
